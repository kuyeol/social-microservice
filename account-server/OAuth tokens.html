<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <base target="_blank">
    <style>
        /* latin */
        @font-face {
          font-family: 'Comic Neue';
          font-style: normal;
          font-weight: 400;
          src: url(fonts/4UaHrEJDsxBrF37olUeD96rp57F2IwM.woff2) format('woff2');
          unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }
        /* latin */
        @font-face {
          font-family: 'Lexend Deca';
          font-style: normal;
          font-weight: 400;
          src: url(fonts/K2FifZFYk-dHSE0UPPuwQ7CrD94i-NCKm-U48M1wqxnDirZPl3v-.woff2) format('woff2');
          unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }
        /* latin */
        @font-face {
          font-family: 'Poppins';
          font-style: normal;
          font-weight: 400;
          src: url(fonts/pxiEyp8kv8JHgFVrJJfecnFHGPc.woff2) format('woff2');
          unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        :root {
          --fg: #000; /* foreground  */
          --bg: #fff; /* background  */
          --bd: #000; /* border  */
          --lk: #006fa5; /* link */
          --lkv: #d33bf0; /* link visited */
          --hg: #ffff81; /* highlight  */
        }
        html {
          overflow: overlay;
        }
        body {
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          margin: 30px auto 0 auto;
          padding: 10px;
          position: relative;

          color: var(--fg);
          border-color: var(--bd);
          background-color: var(--bg);
        }
        body[data-mode$="dark"] {
          --lk: #0096de;
        }
        body[data-mode="light"] {
          color-scheme: light;
          --fg: #222;
          --bd: #222;
          --bg: whitesmoke;
        }
        body[data-mode="dark"] {
          color-scheme: dark;
          --fg: #eee;
          --bd: #eee;
          --bg: #333;
        }
        body[data-mode="sepia"] {
          color-scheme: light;
          --fg: #5b4636;
          --bd: #5b4636;
          --bg: #f4ecd8;
        }
        body[data-mode="solarized-light"] {
          color-scheme: light;
          --fg: #586e75;
          --bd: #586e75;
          --bg: #fdf6e3;
        }
        body[data-mode="nord-light"] {
          color-scheme: light;
          --fg: #2e3440;
          --bd: #2e3440;
          --bg: #e5e9f0;
        }
        body[data-mode="groove-dark"] {
          color-scheme: dark;
          --fg: #cec4ac;
          --bd: #cec4ac;
          --bg: #282828;
        }
        body[data-mode="solarized-dark"] {
          color-scheme: dark;
          --fg: #839496;
          --bd: #839496;
          --bg: #002b36;
        }
        body[data-mode="nord-dark"] {
          color-scheme: dark;
          --fg: #e5e9f0;
          --bd: #e5e9f0;
          --bg: #2e3440;
        }

        @media print {
          body[data-mode] {
            --fg: #000;
            --bd: #000;
            --bg: #fff;

            width: unset;
            padding: 0;
            margin: 0;
          }
        }
        body[data-loaded=true] {

        }
        img {
          max-width: 100%;
          height: auto;
        }
        img:not([width])[src$=".svg"] {
          max-width: 100px;
        }
        body[data-images=false] canvas,
        body[data-images=false] svg,
        body[data-images=false] img {
          display: none;
        }
        svg:not([width]):not([height]) {
          max-width: 25vmin;
        }
        a {
          color: var(--lk);
          text-decoration: none;
        }
        a:visited {
          color: var(--lkv);
        }

        hr {
          background-color: var(--bd);
          height: 1px;
          border: 0;
        }
        #reader-domain {
          font-family: Helvetica, Arial, sans-serif;
          text-decoration: none;
          border-bottom-color: currentcolor;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          width: 100%;
          display: inline-block;
          direction: ltr;
        }
        #reader-domain > span:first-child {
          font-size: 1.1em;
        }
        #reader-domain > span:last-child {
          font-size: 0.8em;
        }
        #reader-title {
          font-size: 1.6em;
          line-height: 1.25em;
          width: 100%;
          margin: 20px 0;
          padding: 0;
        }
        #reader-credits,
        #doi,
        #published-time,
        #reader-estimated-time {
          font-size: 0.85em;
          line-height: 1.48em;
          margin: 0 0 10px 0;
          padding: 0;
        }
        #reader-credits:not(:empty)::after {
          content: ' ⋮ ';
        }
        #published-time:not(:empty)::before {
          content: ' ⋮ ';
        }
        #doi-json {
          overflow: hidden;
        }
        #doi-json code {
          overflow: auto;
          max-height: 400px;
        }
        #published-time:empty,
        #reader-credits:empty {
          display: none;
        }
        mark.hghlght {
          background-color: var(--hg);
        }
        body:not([data-columns="1"]) .page :is(h1, h2) {
          column-span: all;
          background-color: rgba(125, 125, 125, 0.1);
          padding: 10px;
        }
        .hidden {
          display: none;
        }
    </style>
    <style id="user-css">body {
  padding-bottom: 64px;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}
    </style>
    <title>Chapter 11. OAuth tokens</title><title>Chapter 11. OAuth tokens :: Reader View</title>
</head>
<body tabindex="1" data-images="true" data-mode="nord-dark" data-font="sans-serif" data-columns="1"
      data-loaded="true">
<span></span> <!-- for IntersectionObserver -->
<a id="reader-domain"
   href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_024.html">
    <span>learning.oreilly.com</span>
    <span>/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_024.html</span>
</a>
<h1 dir="auto" id="reader-title">Chapter 11. OAuth tokens</h1>
<span dir="auto" id="reader-credits"></span>
<span dir="auto" id="reader-estimated-time">46-59 minutes</span>
<span dir="auto" id="published-time"></span>
<hr>
<div id="readability-page-1" class="page">
    <div id="sbo-rt-content">

        <p><a id="iddle1740"></a><a
        id="iddle1751"></a><i><span><span>이 장에서는 다음 내용을 다룹니다.</span></span></i></p>


        <ul>
            <li><span><span>OAuth 토큰이란?</span></span></li>

            <li><span><span>구조화된 JSON 웹 토큰(JWT)에 정보 포함</span></span></li>

            <li><span><span>JOSE를 사용하여 토큰 데이터 보호</span></span></li>

            <li><span><span>토큰 내성을 통해 실시간으로 토큰 정보 조회</span></span></li>

            <li><span><span>토큰 취소를 통한 토큰 수명 주기 관리</span></span></li>
        </ul>

        <p><span><span>모든 리디렉션, 흐름 및 구성 요소에 대해 OAuth 프로토콜은 궁극적으로 토큰에 관한 것입니다. </span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_011.html#ch01"><span><span>1장의</span></span></a><span><span> 클라우드 인쇄 예제를 다시 생각해 보세요. 사진 저장 서비스가 프린터가 사진에 액세스할 수 있다는 것을 알기 위해 프린터 서비스는 해당 권한을 증명하는 무언가를 제공해야 했습니다. 프린터가 저장 서비스에 제공하는 것을 </span></span><i><span><span>액세스 토큰</span></span></i><span><span> 이라고 하며 , 이 책 전체에서 이미 광범위하게 작업했습니다. 이제 OAuth 토큰과 OAuth 생태계에서 이를 관리하는 것에 대해 자세히 살펴보겠습니다.</span></span>
        </p>

        <h3 id="ch11lev1sec1"><a
        id="ch11lev1sec1__title"></a><span><span>11.1. OAuth 토큰이란 무엇인가요?</span></span></h3>

        <p><span><span>토큰은 모든 OAuth 거래의 핵심입니다. 클라이언트는 권한 부여 서버에서 토큰을 가져와 보호된 리소스에 제공합니다. 권한 부여 서버는 토큰을 생성하여 클라이언트에 배포하고, 리소스 소유자 위임과 클라이언트 권한을 관리하여 토큰에 첨부합니다. 보호된 리소스는 클라이언트로부터 토큰을 수신하여 이를 검증하고 첨부된 권한과 권리를 클라이언트가 요청한 것과 일치시킵니다.</span></span>
        </p>

        <p><span><span>토큰은 위임 행위의 결과를 나타냅니다. 리소스 소유자, 클라이언트, 권한 부여 서버, 보호된 리소스, 범위 및 권한 부여 결정에 대한 모든 것의 튜플입니다. 클라이언트가 리소스 소유자를 다시 귀찮게 하지 않고 액세스 토큰을 새로 고쳐야 할 때 다른 토큰인 새로 고침 토큰을 사용하여 이를 수행합니다. OAuth 토큰은 OAuth의 전체 생태계의 중심에 있는 핵심 메커니즘이며 토큰이 없으면 OAuth가 없다고 할 수 있습니다. OAuth의 비공식 로고조차도 물리적 버스 토큰의 모양을 기반으로 합니다( </span></span><a
        href="#ch11fig01"><span><span>그림 11.1</span></span></a><span><span> ).</span></span></p>

        <h5 id="ch11fig01"><span><span>그림 11.1.</span></span><a
        id="ch11fig01__title"></a><span><span>버스 토큰을 모델로 한 비공식 OAuth 로고</span></span></h5>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/11fig01.jpg"
                width="287" height="287"></p>

        <p><span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_012.html#ch02"><span><span>그러나 토큰에 대한 이 모든 초점에도 불구하고 OAuth는 토큰의 내용이 무엇인지에 대해 전혀 주장하거나 언급하지 않습니다. 2장</span></span></a><span><span> 과 </span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_014.html#ch03"
        aria-label="각주 3"><span><span>3</span></span></a><span><span> 장 에서 논의했듯이 </span><span>OAuth의 클라이언트는 토큰 자체에 대해 아무것도 알 필요가 없습니다. 클라이언트가 이해해야 할 것은 권한 부여 서버에서 토큰을 가져오는 방법과 리소스 서버에서 토큰을 사용하는 방법뿐입니다. 그러나 권한 부여 서버와 리소스 서버는 토큰에 대해 알아야 합니다. 권한 부여 서버는 클라이언트에게 제공할 토큰을 만드는 방법을 알아야 하고, 리소스 서버는 클라이언트가 전달한 토큰을 인식하고 검증하는 방법을 알아야 합니다.</span></span>
        </p>

        <p><span><span>OAuth 핵심 사양에서 왜 이렇게 기본적인 것을 빼먹었을까요? 토큰 자체를 지정하지 않음으로써 OAuth는 다양한 특성, 위험 프로필 및 요구 사항이 있는 광범위한 배포에서 사용될 수 있습니다. OAuth 토큰은 만료되거나 취소 가능하거나 무기한이거나 상황에 따라 이러한 것들의 조합일 수 있습니다. 특정 사용자 또는 시스템의 모든 사용자 또는 전혀 사용자를 나타낼 수 있습니다. 내부 구조를 가질 수도 있고, 무작위적인 넌센스이거나, 암호로 보호되거나, 심지어 이러한 옵션의 조합일 수도 있습니다. 이러한 유연성과 모듈성 덕분에 OAuth는 토큰 형식을 지정하고 시스템의 모든 당사자가 이해해야 하는 WS-*, SAML 및 Kerberos와 같은 보다 포괄적인 보안 프로토콜에서는 어려운 방식으로 조정될 수 있습니다.</span></span>
        </p>

        <p>
            <span><span>그래도 토큰을 만들고 검증하는 데는 몇 가지 일반적인 기술이 있으며, 각각 장단점이 있어 다양한 상황에 적용할 수 있습니다. 이 책의 </span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_014.html#ch03"><span><span>3장</span></span></a><span><span> , </span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_015.html#ch04"
        aria-label="각주 4"><span><span>4</span></span></a><span><span> 장 , </span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_016.html#ch05"
        aria-label="각주 5"><span><span>5장의</span></span></a><span><span> 연습에서 우리는 영숫자 문자의 무작위 덩어리인 토큰을 만들었습니다. 전선에서 보면 다음과 같습니다.</span></span>
        </p>
        <div data-testid="custom pre block">
            <pre id="PLd0e13771"><span><span>s9nR4qv7qVadTUssVD5DqA7oRLJ2xonn</span></span></pre>
        </div>

        <p><span><span>권한 부여 서버가 토큰을 생성했을 때, 토큰의 값을 디스크의 공유 데이터베이스에 저장했습니다. 보호된 리소스가 클라이언트로부터 토큰을 받았을 때, 토큰의 값을 같은 데이터베이스에서 조회하여 토큰의 용도를 파악했습니다. 이러한 토큰은 내부에 정보를 담고 있지 않고 대신 간단한</span></span><a
        id="iddle1432"></a><a id="iddle1437"></a><a id="iddle1710"></a><a id="iddle1713"></a><a
        id="iddle1788"></a><span><span>데이터 조회를 위한 핸들. 이것은 액세스 토큰을 만들고 관리하는 완벽하게 유효하고 드문 일이 아닌 방법이며, 토큰 자체를 작게 유지하면서도 많은 양의 엔트로피를 제공할 수 있다는 이점이 있습니다.</span></span>
        </p>

        <p><span><span>권한 부여 서버와 보호 리소스 간에 데이터베이스를 공유하는 것이 항상 실용적인 것은 아닙니다. 특히 단일 권한 부여 서버가 다운스트림에서 여러 개의 다른 보호 리소스를 보호하고 있는 경우 더욱 그렇습니다. 그러면 대신 무엇을 할 수 있을까요? 이 장에서는 두 가지 다른 일반적인 옵션인 구조화된 토큰과 토큰 내성을 살펴보겠습니다.</span></span>
        </p>

        <h3 id="ch11lev1sec2"><a id="ch11lev1sec2__title"></a><span><span>11.2. 구조화된 토큰: JSON 웹 토큰(JWT)</span></span>
        </h3>

        <p><span><span>공유 데이터베이스를 조회하는 대신, 필요한 모든 정보가 들어 있는 토큰을 만들 수 있다면 어떨까요? 이런 방식으로 권한 부여 서버는 네트워크 API 호출을 사용하지 않고도 토큰 자체를 통해 보호된 리소스와 간접적으로 통신할 수 있습니다.</span></span>
        </p>

        <p><span><span>이 방법을 사용하면 권한 부여 서버는 토큰의 만료 타임스탬프와 권한을 부여한 사용자와 같이 보호된 리소스가 알아야 할 모든 정보를 패킹합니다. 이 모든 정보가 클라이언트로 전송되지만 클라이언트는 토큰이 모든 OAuth 2.0 시스템에서 클라이언트에게 불투명하게 남아 있기 때문에 이를 알아차리지 못합니다. 클라이언트가 토큰을 얻으면 토큰을 임의의 블롭처럼 보호된 리소스로 전송합니다. 토큰을 이해해야 하는 보호된 리소스는 토큰에 포함된 정보를 구문 분석하고 이를 기반으로 권한 부여 결정을 내립니다.</span></span>
        </p>

        <h4 id="ch11lev2sec1"><span><span>11.2.1.</span></span><a
        id="ch11lev2sec1__title"></a><span><span>JWT의 구조</span></span></h4>

        <p>
            <span><span>이런 종류의 토큰을 만들려면 전달하려는 정보를 구조화하고 직렬화하는 방법이 필요합니다. JSON 웹 토큰 </span></span><sup><span><span>[ </span></span><a
        href="#ch11fn01"
        aria-label="각주 1"><span><span>1</span></span></a><span><span> ]</span></span></sup><span><span> 형식 또는 JWT </span></span><sup><span><span>[ </span></span><a
        href="#ch11fn02"
        aria-label="각주 2"><span><span>2</span></span></a><span><span> ]</span></span></sup><span><span> 는 토큰과 함께 보내야 하는 종류의 정보를 전달하는 간단한 방법을 제공합니다. 핵심적으로 JWT는 와이어를 통해 전송할 수 있도록 형식으로 래핑된 JSON 객체입니다. 가장 간단한 형태의 JWT인 서명되지 않은 토큰은 다음과 같습니다.</span></span>
        </p>

        <blockquote>
            <p><sup><a id="ch11fn01" aria-label="각주 1"><span><span>1</span></span></a></sup></p>


        </blockquote>

        <blockquote>
            <p><sup><a id="ch11fn02" aria-label="각주 2"><span><span>2</span></span></a></sup></p>

            <p><span><span>
      일반적으로 "조트"라고 발음합니다.
    </span></span></p>


        </blockquote>
        <div data-testid="custom pre block"><pre id="PLd0e13850"><span><span>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpva</span></span><span></span><span><span>
  G4gRG9l이이위YWRtaW4iOnRydWV9.</span></span></pre>
        </div>

        <p><span><span>이것은 우리가 이전에 사용하던 토큰과 마찬가지로 무작위 블롭처럼 보일 수 있지만, 여기에는 훨씬 더 많은 것이 있습니다. 첫째, 단일 마침표로 구분된 두 개의 문자 섹션이 있다는 점에 유의하십시오. 이들 각각은 토큰의 다른 부분이며, 토큰 문자열을 점 문자로 분할하면 섹션을 별도로 처리할 수 있습니다. (예제에서 마지막 점 뒤에 세 번째 섹션이 암시되지만, </span></span><a
        href="#ch11lev1sec3"><span><span>섹션 11.3</span></span></a><span><span> 에서 다룰 것입니다 .)</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e13862"><span><span>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0</span></span><span></span><span><span>
.</span></span><span></span><span><span>
아이제이제이디위이오이이엑스엠제이엠0NTY3ODkw이이위브엠FtZSI6이크피바G4gRG9l이이위YWR타W4이온리드WV9</span></span><span></span><span><span>
.</span></span></pre>
        </div>

        <p><a id="iddle1022"></a><a id="iddle1143"></a><a id="iddle1800"></a><span><span>점 사이의 각 값은 무작위가 아니라 Base64URL로 인코딩된 JSON 개체입니다. </span></span><sup><span><span>[ </span></span><a
        href="#ch11fn03"
        aria-label="각주 3"><span><span>3</span></span></a><span><span> ]</span></span></sup><span><span> Base64를 디코딩하고 첫 번째 섹션 내부의 JSON 개체를 구문 분석하면 간단한 개체를 얻습니다.</span></span>
        </p>

        <blockquote>
            <p><sup><a id="ch11fn03" aria-label="각주 3"><span><span>3</span></span></a></sup></p>

            <p><span><span>
      구체적으로 말하면 URL 안전 알파벳을 사용하고 패딩 문자가 없는 Base64 인코딩입니다.
    </span></span></p>


        </blockquote>
        <div data-testid="custom pre block"><pre
        id="PLd0e13891"><span><span>{</span></span><span></span><span><span>
  "typ": "JWT",</span></span><span></span><span><span>
  "alg": "없음"</span></span><span></span><span><span>
}</span></span></pre>
        </div>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <div>
            <p><b id="ch11sb01"><span><span>왜 Base64인가?</span></span></b></p>
            <p><span><span>왜 우리는 Base64로 모든 것을 인코딩하는 데 어려움을 겪을까요?결국, 인간이 읽을 수 없고, 그것을 이해하려면 추가 처리 단계가 필요합니다.JSON을 직접 사용하는 것이 더 낫지 않을까요?답의 일부는 JWT가 일반적으로 있는 곳에서 나옵니다.HTTP 헤더, 쿼리 매개변수, 양식 매개변수, 다양한 데이터베이스 및 프로그래밍 언어의 문자열입니다.이러한 각 위치는 추가 인코딩 없이도 사용할 수 있는 제한된 문자 집합을 갖는 경향이 있습니다.예를 들어, HTTP 양식 매개변수를 통해 JSON 객체를 보내려면 여는 괄호와 닫는 괄호 </span></span><kbd>{</kbd><span><span>및 를 각각 </span><span>및 </span></span><kbd>}</kbd><span><span>로 인코딩해야 합니다 </span><span>.따옴표, 콜론 및 기타 일반적인 문자도 적절한 엔터티 코드로 인코딩해야 합니다.공백 문자와 같이 일반적인 문자조차도 </span><span>토큰의 위치에 따라 </span><span>또는 로 인코딩될 수 있습니다.또한 많은 경우 </span><span>인코딩에 사용된 문자 자체를 인코딩해야 하며, 종종 값을 실수로 이중 인코딩하는 경우가 있습니다.</span></span><kbd>%7B</kbd><span></span><kbd>%7D</kbd><span></span><kbd>%20</kbd><span></span><kbd>+</kbd><span></span><kbd>%</kbd><span></span>
            </p>

            <p><span><span>Base64URL 인코딩 체계를 기본적으로 사용함으로써 JWT는 추가 인코딩 없이 이러한 일반적인 위치에 안전하게 배치될 수 있습니다. 또한 JSON 객체는 인코딩된 문자열로 제공되므로 처리 미들웨어에서 처리 및 재직렬화될 가능성이 낮습니다. 이는 다음 섹션에서 중요한 사항입니다. 이러한 종류의 전송 저항성 갑옷은 배포 및 개발자에게 매력적이며 JWT가 다른 보안 토큰 형식이 흔들린 곳에서 발판을 찾는 데 도움이 되었습니다.</span></span>
            </p>
        </div>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <p>
            <span><span>이 헤더는 항상 JSON 객체이며 나머지 토큰에 대한 정보를 설명하는 데 사용됩니다. </span></span><kbd>typ</kbd><span><span>헤더는 나머지 토큰을 처리하는 애플리케이션에 두 번째 섹션인 페이로드에서 무엇을 기대해야 하는지 알려줍니다. 우리의 예에서는 JWT라고 알려줍니다. 이와 동일한 구조를 사용할 수 있는 다른 데이터 컨테이너가 있지만 JWT는 가장 일반적이고 OAuth 토큰으로서 우리의 목적에 가장 적합합니다. 여기에는 이것이 서명되지 않은 토큰임을 나타내는 </span></span><kbd>alg</kbd><span><span>특수 값이 있는 헤더 도 포함됩니다 </span></span><kbd>none</kbd><span><span>.</span></span>
        </p>

        <p><span><span>두 번째 섹션은 토큰 자체의 페이로드이며 헤더와 같은 방식으로 직렬화됩니다. Base64URL로 인코딩된 JSON입니다. 이것은 JWT이므로 페이로드는 모든 JSON 객체가 될 수 있으며 이전 예에서는 간단한 사용자 데이터 집합입니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre
        id="PLd0e13945"><span><span>{</span></span><span></span><span><span>
  "sub": "1234567890",</span></span><span></span><span><span>
  "name": "존 도",</span></span><span></span><span><span>
  "admin": 참</span></span><span></span><span><span>
}</span></span></pre>
        </div>

        <h4 id="ch11lev2sec2"><span><span>11.2.2.</span></span><a
        id="ch11lev2sec2__title"></a><span><span>JWT 클레임</span></span></h4>

        <p><a id="iddle1048"></a><a id="iddle1168"></a><a id="iddle1329"></a><a
        id="iddle1331"></a><a id="iddle1384"></a><a id="iddle1413"></a><a id="iddle1415"></a><a
        id="iddle1425"></a><a id="iddle1434"></a><a id="iddle1448"></a><a id="iddle1455"></a><a
        id="iddle1711"></a><a id="iddle1714"></a><a id="iddle1806"></a><span><span>JWT는 일반적인 데이터 구조 외에도 다양한 애플리케이션에서 사용할 수 있는 클레임 ​​세트를 제공합니다. JWT는 모든 유효한 JSON 데이터를 포함할 수 있지만 이러한 클레임은 이러한 종류의 토큰을 포함하는 일반적인 작업에 대한 지원을 제공합니다. 이러한 모든 필드는 JWT에서 선택 사항이지만 특정 서비스는 자체 포함 요구 사항을 정의할 수 있습니다( </span></span><a
        href="#ch11table01"><span><span>표 11.1</span></span></a><span><span> ).</span></span></p>

        <p><span><span>또한 특정 애플리케이션에 필요한 추가 필드를 추가할 수도 있습니다. 이전 예제 토큰에서 페이로드에 </span></span><kbd>name</kbd><span><span>및 </span></span><kbd>admin</kbd><span><span>필드를 추가하여 사용자의 표시 이름과 이 사용자가 관리자인지 여부를 나타내는 부울 필드를 제공했습니다. 이러한 필드의 값은 문자열, 숫자, 배열 또는 다른 객체를 포함한 모든 유효한 JSON 값이 될 수 있습니다.</span></span>
        </p>

        <h5 id="ch11table01"><span><span>표 11.1.</span></span><a
        id="ch11table01__title"></a><span><span>표준 JSON 웹 토큰 클레임</span></span></h5>

        <table>
            <colgroup span="2">
                <col width="100">
                <col width="500">
            </colgroup>
            <thead>
            <tr>
                <th scope="col">
                    <p><span><span>클레임 이름</span></span></p>
                </th>
                <th scope="col">
                    <p><span><span>청구 설명</span></span></p>
                </th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><span><span>이스</span></span></td>
                <td>
                    <span><span>토큰의 발급자 </span></span><i><span><span>. 이는 </span></span></i><span></span><i><span><span>이 토큰을 만든 사람</span></span></i><span><span> 의 지표이며 </span><span>, 많은 OAuth 배포에서 이는 권한 부여 서버의 URL입니다. 이 클레임은 단일 문자열입니다.</span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>보결</span></span></td>
                <td><span><span>토큰의 주체. 이는 토큰이 누구에 대한 것인지를 나타내는 지표이며 </span><span>, </span><i><span>많은 OAuth 배포 </span></i></span><i><span><span>에서</span></span></i><span><span> 이는 리소스 소유자의 고유 식별자입니다. 대부분의 경우 주체는 발급자의 범위 내에서만 고유해야 합니다. 이 클레임은 단일 문자열입니다.</span></span><i><span></span></i><span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>호주 달러</span></span></td>
                <td><span><span>토큰의 대상 . 이는 </span><i><span>토큰을 수락해야 하는 사람</span></i><span> 의 지표이며 , 많은 OAuth 배포에서 여기 </span></span><i><span><span>에는</span></span></i><span><span> 토큰을 보낼 수 있는 보호된 리소스 또는 보호된 리소스의 URI가 포함됩니다. 이 클레임은 문자열 배열이거나, 값이 하나뿐인 경우 배열로 래핑되지 않은 단일 문자열일 수 있습니다.</span></span><i><span></span></i><span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>경험치</span></span></td>
                <td><span><span>토큰의 </span></span><i><span><span>만료 타임</span></span></i><span><span> 스탬프 입니다. </span></span><i><span><span>토큰이 저절로 만료되는</span></span></i><span><span> 배포의 경우 토큰이 만료되는 시점을 나타내는 지표입니다. 이 클레임은 그리니치 표준시(GMT) 시간대로 1970년 1월 1일 자정, UNIX Epoch 이후의 초 수를 나타내는 정수입니다.</span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>영어: nbf는</span></span></td>
                <td><span><span>토큰의 not-before 타임스탬프. 토큰이 유효해지기 전에 발급될 수 있는 배포의 경우 토큰이 유효해지기 시작하는 시점을 나타내는 지표입니다 </span><span>. </span></span><i><span><span>이 </span></span></i><span></span><i><span><span>클레임</span></span></i><span><span> 은 GMT 시간대의 UNIX Epoch인 1970년 1월 1일 자정 이후의 초 수를 나타내는 정수입니다.</span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>아이에이티</span></span></td>
                <td>
                    <span><span>토큰의 발행-시간 타임스탬프. 이는 토큰이 생성된 시점을 나타내는 지표이며 </span><span>, </span></span><i><span><span>일반적 </span></span></i><span></span><i><span><span>으로</span></span></i><span><span> 토큰 생성 시점의 발행자의 시스템 타임스탬프입니다. 이 클레임은 GMT 시간대의 UNIX Epoch인 1970년 1월 1일 자정 이후의 초 수를 나타내는 정수입니다.</span></span>
                </td>
            </tr>
            <tr>
                <td><span><span>제이티</span></span></td>
                <td>
                    <span><span>토큰의 고유 식별자입니다. 이는 발급자가 만든 각 토큰에 고유한 값이며 </span><span>, </span></span><i><span><span>충돌 </span></span></i><span></span><i><span><span>을</span></span></i><span><span> 방지하기 위해 종종 암호학적으로 무작위적인 값입니다. 이 값은 공격자가 사용할 수 없는 구조화된 토큰에 무작위 엔트로피 구성 요소를 추가하여 토큰 추측 및 재생 공격을 방지하는 데에도 유용합니다.</span></span>
                </td>
            </tr>
            </tbody>
        </table>

        <p><a id="iddle1134"></a><a id="iddle1436"></a><a id="iddle1712"></a><span><span>이러한 필드의 이름은 다른 모든 JSON 객체에 해당되는 모든 유효한 JSON 문자열일 수 있지만 JWT 사양 </span></span><sup><span><span>[ </span></span><a
        href="#ch11fn04"
        aria-label="각주 4"><span><span>4</span></span></a><span><span> ]</span></span></sup><span><span> 에는 JWT 구현 간의 충돌을 피하기 위한 몇 가지 지침이 있습니다. 이러한 지침은 JWT가 다양한 클레임을 정의하고 잠재적으로 서로 다른 의미를 가질 수 있는 보안 도메인에서 사용되도록 의도된 경우에 특히 유용합니다.</span></span>
        </p>

        <blockquote>
            <p><sup><a id="ch11fn04" aria-label="각주 4"><span><span>4</span></span></a></sup></p>


        </blockquote>

        <h4 id="ch11lev2sec3"><span><span>11.2.3.</span></span><a
        id="ch11lev2sec3__title"></a><span><span>우리 서버에 JWT 구현하기</span></span></h4>

        <p><span><span>권한 부여 서버에 JWT 지원을 추가해 보겠습니다. 파일을 열고 </span></span><kbd>ch-11-ex-1</kbd><span><span>편집합니다 . </span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_016.html#ch05"><span>5장</span></a></span><kbd>authorizationServer.js</kbd><span><span> 에서 </span><span>구조화되지 않고 무작위 토큰을 발행하는 서버를 만들었습니다. 여기서는 서명되지 않은 JWT 형식의 토큰을 생성하도록 서버를 수정합니다. 실제로는 JWT 라이브러리를 사용하는 것이 좋지만, 토큰에 무엇이 들어가는지 느낄 수 있도록 JWT를 직접 생성합니다. 다음 섹션에서 JWT 라이브러리를 조금 더 사용해 볼 수 있습니다.</span></span><a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_016.html#ch05"><span></span></a><span></span>
        </p>

        <p><span><span>먼저 토큰 자체를 생성하는 코드 부분을 찾습니다. 이 섹션에서는 다음 줄을 주석 처리(또는 삭제)하는 것으로 시작하여 모든 코딩을 수행합니다.</span></span>
        </p>
        <div data-testid="custom pre block">
            <pre
            id="PLd0e14258"><span><span>var 액세스 토큰 = randomstring.generate();</span></span></pre>
        </div>

        <p><span><span>JWT를 만들려면 먼저 헤더가 필요합니다. 이전 예제 토큰에서와 같이 이 토큰이 JWT이고 서명되지 않았다는 것을 나타낼 것입니다. 서버에서 오는 모든 토큰은 동일한 특성을 갖기 때문에 여기서 정적 객체를 사용할 수 있습니다.</span></span>
        </p>
        <div data-testid="custom pre block">
            <pre
            id="PLd0e14267"><span><span>var header = { 'typ': 'JWT', 'alg': 'none' };</span></span></pre>
        </div>

        <p><span><span>다음으로, JWT의 페이로드를 보관할 객체를 만들고 토큰에서 중요하게 여기는 사항에 따라 필드를 할당합니다. 모든 토큰에 대해 동일한 발급자를 권한 부여 서버의 URL로 설정하고 권한 부여 페이지의 사용자 변수를 토큰의 주체로 사용합니다(존재하는 경우). 또한 토큰의 대상을 보호된 리소스의 URL로 설정합니다. 토큰이 발급된 시간의 타임스탬프를 표시하고 토큰이 5분 후에 만료되도록 설정합니다. JavaScript는 기본적으로 타임스탬프를 밀리초 단위로 처리하는 반면 JWT 사양에서는 모든 것이 초 단위여야 합니다. 따라서 기본 값으로 변환하거나 기본 값에서 변환할 때 1000배를 고려해야 합니다. 마지막으로 원래 전체 토큰 값을 생성하는 데 사용한 것과 동일한 임의 문자열 생성 함수를 사용하여 토큰의 임의 식별자를 추가합니다. 모두 합쳐서 페이로드를 만드는 것은 다음과 같습니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre
        id="PLd0e14276"><span><span>var 페이로드 = {</span></span><span></span><span><span>
  iss: 'http://localhost:9001/',</span></span><span></span><span><span>
  sub: code.user ? code.user.sub : 정의되지 않음,</span></span><span></span><span><span>
  오디오: 'http://localhost:9002/',</span></span><span></span><span><span>
  iat: Math.floor(Date.now() / 1000),</span></span><span></span><span><span>
  exp: Math.floor(Date.now() / 1000) + (5 * 60),</span></span><span></span><span><span>
  jti: 랜덤문자열 생성(8)</span></span><span></span><span><span>
};</span></span></pre>
        </div>

        <p><a id="iddle1334"></a><a id="iddle1551"></a><span><span>이렇게 하면 다음과 비슷한 객체를 얻을 수 있지만 물론 타임스탬프와 무작위 문자열은 다를 것입니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre
        id="PLd0e14296"><span><span>{</span></span><span></span><span><span>
  "iss": "http://localhost:9001/",</span></span><span></span><span><span>
  "sub": "앨리스",</span></span><span></span><span><span>
  "aud": "http://localhost:/9002/",</span></span><span></span><span><span>
  "iat": 1440538696,</span></span><span></span><span><span>
  "exp": 1440538996,</span></span><span></span><span><span>
  "jti": "Sl66JdkQ"</span></span><span></span><span><span>
}</span></span></pre>
        </div>

        <p><span><span>그런 다음 헤더와 페이로드 객체를 가져와 JSON을 문자열로 직렬화하고, Base64URL 인코딩을 사용하여 해당 문자열을 인코딩하고, 마침표를 구분 기호로 사용하여 연결할 수 있습니다. JSON 객체를 직렬화할 때 특별한 작업을 할 필요가 없고, 필드의 특별한 형식이나 순서도 없으며, 모든 표준 JSON 직렬화 함수가 가능합니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14305"><span><span>var 액세스 토큰 = base64url.encode(JSON.stringify(헤더))</span></span><span></span><span><span>
  + '.'</span></span><span></span><span><span>
  + base64url.encode(JSON.stringify(페이로드))</span></span><span></span><span><span>
  + '.';</span></span></pre>
        </div>

        <p><span><span>이제 우리의 </span></span><kbd>access_token</kbd><span><span>값은 다음과 같은 서명되지 않은 JWT와 유사합니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14317"><span><span>eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEvI</span></span><span></span><span><span>
   iwic3ViIjoiOVhFMy1KSTM0LTAwMTMyQSIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMi</span></span><span></span><span><span>
   영어: 8iLCJpYXQiOjE0NjcyNDk3NzQsImV4cCI6MTQ2NzI1MDA3NCwianRpIjoiMFgyd2lQanUifQ.에서 유래됨.</span></span></pre>
        </div>

        <p><span><span>토큰에 만료일이 연관되어 있지만 클라이언트는 해당 변경 사항에 대해 특별한 작업을 할 필요가 없습니다. 클라이언트는 토큰이 작동을 멈출 때까지 계속 사용할 수 있으며, 이때 클라이언트는 평소처럼 다른 토큰을 가져옵니다. 권한 부여 서버는 토큰 응답 필드를 사용하여 클라이언트에 만료 힌트를 제공할 수 있지만 클라이언트는 </span><i><span>그</span></i></span><kbd>expires_in</kbd><span><span> 작업을 할 필요도 없고 </span><span>대부분 클라이언트가 그렇게 하지 않습니다.</span></span><i><span></span></i><span></span>
        </p>

        <p><span><span>이제 보호된 리소스가 데이터베이스에서 토큰 값을 찾는 대신 들어오는 토큰에서 정보를 확인할 때입니다. </span></span><kbd>protected-Resource.js</kbd><span><span>들어오는 토큰을 처리하는 코드를 열어서 찾습니다. 먼저 권한 부여 서버가 토큰을 생성하는 데 사용한 것과 반대되는 작업을 수행하여 토큰을 구문 분석해야 합니다. 즉, 점 문자로 분할하여 다른 섹션을 가져옵니다. 그런 다음 두 번째 부분인 페이로드를 Base64 URL에서 디코딩하고 결과를 JSON 객체로 구문 분석합니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14338"><span><span>var tokenParts = inToken.split('.');</span></span><span></span><span><span>
var 페이로드 = JSON.parse(base64url.decode(tokenParts[1]));</span></span></pre>
        </div>

        <p><span><span>이렇게 하면 애플리케이션에서 확인할 수 있는 네이티브 데이터 구조가 생깁니다. 토큰이 예상 발급자로부터 왔는지, 타임스탬프가 올바른 범위에 맞는지, 리소스 서버가 토큰의 의도된 대상인지 확인할 것입니다. 이러한 종류의 검사는 종종 부울 논리와 함께 연결되지만,</span></span><a
        id="iddle1277"></a><a id="iddle1419"></a><a id="iddle1672"></a><a
        id="iddle1749"></a><span></span><kbd>if</kbd><span><span>각 수표를 보다 명확하고 독립적으로 읽을 수 있도록 </span><span>이를 개별 문장으로 나누었습니다 .</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14378"><span><span>if (payload.iss == 'http://localhost:9001/') {</span></span><span></span><span><span>
  if ((Array.isArray(payload.aud) &amp;&amp; __.contains(payload.aud, 'http://localhost:9002/')) ||</span></span><span></span><span><span>
            payload.aud == 'http://localhost:9002/') {</span></span><span></span><span><span>
      var now = Math.floor(Date.now() / 1000);</span></span><span></span><span><span>
      if (payload.iat &lt;= 지금) {</span></span><span></span><span><span>
            if (payload.exp &gt;= 현재) {</span></span><span></span>
                  <b><span><span>req.access_token = 페이로드;</span></span></b><span></span><span><span>
            }</span></span><span></span><span><span>
      }</span></span><span></span><span><span>
  }</span></span><span></span><span><span>
}</span></span></pre>
        </div>

        <p><span><span>모든 체크를 통과하면, 우리는 토큰을 파싱하여 </span></span><kbd>payload</kbd><span><span>나머지 애플리케이션에 넘기고, 나머지 애플리케이션은 주체와 같은 필드를 기반으로 권한 부여 결정을 내릴 수 있습니다. 이는 이전 버전의 애플리케이션에서 권한 부여 서버가 데이터베이스에 저장한 데이터를 로드하는 것과 유사합니다.</span></span>
        </p>

        <p><span><span>기억하세요, JWT의 페이로드는 JSON 객체이며, 보호된 리소스는 이제 요청 객체에서 직접 액세스할 수 있습니다. 여기에서 다른 핸들러 함수가 이 특정 토큰이 해당 요청을 처리하기에 충분한지 여부를 판단해야 합니다. 토큰이 공유 데이터베이스에 저장되었을 때와 마찬가지입니다. 예제에서 토큰 본문에 포함된 속성은 그다지 많은 것을 말하지 않지만 클라이언트, 리소스 소유자, 범위 또는 보호된 리소스의 결정과 관련된 기타 정보에 대한 정보를 쉽게 포함할 수 있습니다.</span></span>
        </p>

        <p><span><span>토큰이 발행되기 전과 다르더라도 클라이언트 코드를 전혀 변경할 필요가 없었습니다. 이는 토큰이 클라이언트에게 불투명하기 때문이며, 이는 OAuth 2.0의 핵심 간소화 요소입니다. 사실, 권한 부여 서버는 클라이언트 소프트웨어를 변경하지 않고도 다양한 종류의 토큰 형식을 선택할 수 있었습니다.</span></span>
        </p>

        <p><span><span>토큰 자체에 정보를 담을 수 있게 된 건 좋은 일이지만, 그것으로 충분할까요?</span></span></p>

        <h3 id="ch11lev1sec3"><a id="ch11lev1sec3__title"></a><span><span>11.3. 토큰의 암호화 보호: JSON 객체 서명 및 암호화(JOSE)</span></span>
        </h3>

        <p><span><span>이 시점에서, 저자는 독자인 여러분이 </span></span><i><span><span>매우 안전하지 못한 일을</span></span></i><span><span> 하게 했다는 것을 고백해야 한다고 생각합니다 . 여러분은 이미 이 중요한 누락을 알아차렸을 수 있으며 우리가 정신 나갔는지 궁금할 것입니다. 무엇을 빠뜨렸을까요? 간단히 말해서, 권한 부여 서버가 어떤 식으로도 보호되지 않은 토큰을 출력하고 보호된 리소스가 다른 검사 없이 해당 토큰 내부의 내용을 신뢰하는 경우, 토큰을 일반 텍스트로 수신하는 클라이언트가 보호된 리소스에 제공하기 전에 토큰의 내용을 조작하는 것은 사소한 일입니다. 클라이언트는 권한 부여 서버와 통신하지 않고도 온전한 천으로 자신의 토큰을 만들 수도 있고, 순진한 리소스 서버는 단순히 그것을 수락하고 처리할 것입니다.</span></span>
        </p>

        <p><a id="iddle1135"></a><a id="iddle1279"></a><a id="iddle1367"></a><a
        id="iddle1424"></a><a id="iddle1552"></a><a
        id="iddle1675"></a><span><span>우리는 거의 확실히 </span><span>그런 일이 일어나기를 원하지 </span></span><i><span><span>않으므로 이 토큰에 약간의 보호 기능을 추가해야 합니다.다행히도 우리에게는 이를 수행하는 방법을 정확히 알려주는 사양 모음이 있습니다.JSON 객체 서명 및 암호화 표준 </span></span></i><span></span><sup><span><span>[ </span></span><a
        href="#ch11fn05"
        aria-label="각주 5"><span><span>5</span></span></a><span><span> ] 또는 JOSE </span></span></sup><span></span><sup><span><span>[ </span></span><a
        href="#ch11fn06"
        aria-label="각주 6"><span><span>6</span></span></a><span><span> ]</span></span></sup><span><span> 입니다 . </span><span>이 모음은 기본 데이터 모델로 JSON을 사용하여 서명(JSON 웹 서명 또는 JWS), 암호화(JSON 웹 암호화 또는 JWE), 심지어 키 저장 형식(JSON 웹 키 또는 JWK)까지 제공합니다.마지막 섹션에서 직접 작성한 서명되지 않은 JWT는 JSON 기반 페이로드가 있는 서명되지 않은 JWS 객체의 특수한 경우일 뿐입니다.JOSE의 세부 정보만으로는 책 한 권을 채울 수 있지만, HMAC 서명 체계를 사용한 대칭 서명 및 검증과 RSA 서명 체계를 사용한 비대칭 서명 및 검증의 두 가지 일반적인 경우를 살펴보겠습니다.또한 JWK를 사용하여 공개 및 비공개 RSA 키를 저장합니다.</span></span>
        </p>

        <blockquote>
            <p><sup><a id="ch11fn05" aria-label="각주 5"><span><span>5</span></span></a></sup></p>


        </blockquote>

        <blockquote>
            <p><sup><a id="ch11fn06" aria-label="각주 6"><span><span>6</span></span></a></sup></p>

            <p><span><span>
      스페인어 이름인 호세(José) 또는 "호-자이(ho-zay)"처럼 발음되도록 의도되었습니다.
    </span></span></p>


        </blockquote>

        <p><span><span>무거운 암호화 작업을 하기 위해 JSRSASign이라는 JOSE 라이브러리를 사용할 것입니다. 이 라이브러리는 기본적인 서명 및 키 관리 기능을 제공하지만 암호화는 제공하지 않습니다. 암호화된 토큰은 독자의 연습으로 남겨두겠습니다.</span></span>
        </p>

        <h4 id="ch11lev2sec4"><span><span>11.3.1.</span></span><a
        id="ch11lev2sec4__title"></a><span><span>HS256을 사용한 대칭 서명</span></span></h4>

        <p><span><span>다음 연습에서는 권한 부여 서버에서 공유 비밀을 사용하여 토큰에 서명한 다음 보호된 리소스에서 공유 비밀을 사용하여 해당 토큰을 검증합니다. 권한 부여 서버와 보호된 리소스가 API 키와 유사한 장기 공유 비밀을 가질 만큼 충분히 긴밀하게 연결되어 있지만 각 토큰을 직접 검증할 수 있는 직접 연결이 없는 경우 이 접근 방식이 유용합니다.</span></span>
        </p>

        <p><span><span>이 연습을 위해 파일 을 </span><span>열고 </span></span><kbd>ch-11-ex-2</kbd><span><span>편집하세요 </span><span>. 먼저 권한 부여 서버에 공유 비밀을 추가하겠습니다. 파일 맨 위에서 변수 정의를 찾아서 </span><span>비밀 문자열로 설정했는지 확인하세요. 프로덕션 환경에서 비밀은 일종의 자격 증명 관리 프로세스에 의해 관리될 가능성이 높고, 값이 이렇게 짧거나 입력하기 쉽지는 않지만 연습을 위해 단순화했습니다.</span></span><kbd>authorizationServer.js</kbd><span></span><kbd>protected-Resource.js</kbd><span></span><kbd>sharedTokenSecret</kbd><span></span>
        </p>
        <div data-testid="custom pre block">
            <pre
            id="PLd0e14516"><span><span>var sharedTokenSecret = '공유 OAuth 토큰 비밀번호!';</span></span></pre>
        </div>

        <p><span><span>이제 그 비밀을 사용하여 토큰에 서명합니다. 코드는 마지막 연습처럼 설정되어 서명되지 않은 토큰을 생성하므로 토큰 생성 코드를 찾아 계속합니다. 먼저 헤더 매개변수를 변경하여 HS256 서명 방법을 사용하고 있음을 표시해야 합니다.</span></span>
        </p>
        <div data-testid="custom pre block">
            <pre
            id="PLd0e14525"><span><span>var header = { 'typ': 'JWT', </span></span><b><span><span>'alg': 'HS256'</span></span></b><span><span> };</span></span></pre>
        </div>

        <p><span><span>JOSE 라이브러리는 서명 함수에 데이터를 전달하기 전에 JSON 직렬화(Base64 URL 인코딩은 아님)를 수행하도록 요구하지만 우리는 이미 해당 세트를 가지고 있습니다.</span></span><a
        id="iddle1359"></a><a id="iddle1365"></a><span><span>up. 이번에는 점으로 문자열을 연결하는 대신 JOSE 라이브러리를 사용하여 공유 비밀을 사용하여 토큰에 HMAC 서명 알고리즘을 적용합니다. 선택한 JOSE 라이브러리의 이상한 점 때문에 공유 비밀을 16진수 문자열로 전달해야 합니다. 다른 라이브러리는 키를 올바른 형식으로 가져오는 데 다른 요구 사항이 있습니다. 라이브러리의 출력은 토큰 값으로 사용할 문자열이 됩니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14555"><span><span>var 액세스 토큰 = jose.jws.JWS.sign(헤더.alg,</span></span><span></span><span><span>
  JSON.stringify(헤더),</span></span><span></span><span><span>
  JSON.stringify(페이로드),</span></span><span></span><span><span>
  버퍼.from(sharedTokenSecret).toString('hex'));</span></span></pre>
        </div>

        <p><span><span>최종 JWT는 다음과 같습니다.</span></span></p>
        <div data-testid="custom pre block"><pre id="PLd0e14564"><span><span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEv</span></span><span></span><span><span>
   이위크3비이조이오브hFMy1KSTM0LTAwMTMyQSIs임F1ZCI6임h0dHA6Ly9sb2NhbGhvc3Q6OTAwMi</span></span><span></span><span><span>
   영어: 8iLCJpYXQiOjE0NjcyNTEwNzMsImV4cCI6MTQ2NzI1MTM3마이위안Rp이조이아EZLUUpSNmUifQ.</span></span><span></span><span><span>
   WqRsY03pYwuJTx-9pDQXftkcj7YbRn95o-16NHr부그</span></span></pre>
        </div>

        <p><span><span>헤더와 페이로드는 이전과 마찬가지로 Base64URL로 인코딩된 JSON 문자열로 유지됩니다. 서명은 JWT 형식의 마지막 점 뒤에 Base64URL로 인코딩된 바이트 집합으로 배치되어 </span></span><kbd>header.payload.signature</kbd><span><span>서명된 JWT의 전체 구조를 만듭니다. 점을 기준으로 섹션을 나누면 구조를 보는 것이 조금 더 쉬워집니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e14576"><span><span>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span></span><span></span><span><span>
.</span></span><span></span><span><span>
eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEvIiwic3ViIjoiOVhFMy1KSTM0LTAwMTMyQSIs</span></span><span></span><span><span>
   임F1ZCI6임h0dHA6Ly9sb2NhbGhvc3Q6OTAwMi8iLCJpYXQiOjE0NjcyNTEwNzMs임V4cCI6MT</span></span><span></span><span><span>
   Q2NzI1MTM3마이위안Rp이조이아EZLUUpSNmUifQ</span></span><span></span><span><span>
.</span></span><span></span>
<b><span><span>WqRsY03pYwuJTx-9pDQXftkcj7YbRn95o-16NHr부그</span></span></b></pre>
        </div>

        <p>Now you can see that our unsigned JWT was a case of having an empty (missing) signature
            section. The rest of the server remains unchanged, as we’re still storing the token in
            the database. However, if we wanted to, we could remove the storage requirement on our
            authorization server entirely because the token is recognizable by the server from its
            signature.</p>

        <p>Once again, our client is none the wiser that the token format has changed. However,
            we’re going to need to edit the protected resource so that it can check the token’s
            signature. To do this, open <kbd>protectedResource.js</kbd> and note the same random
            secret string at the top of the file. Once again, in a production environment, this is
            likely handled through a key management process and the secret isn’t likely to be this
            simple to type.</p>
        <div data-testid="custom pre block">
            <pre id="PLd0e14593">var sharedTokenSecret = 'shared OAuth token secret!';</pre>
        </div>

        <p>First we need to parse the token, but that’s pretty much like last time.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14602">var tokenParts = inToken.split('.');<span></span>
var header = JSON.parse(base64url.decode(tokenParts[0]));<span></span>
var payload = JSON.parse(base64url.decode(tokenParts[1]));</pre>
        </div>

        <p><a id="iddle1136"></a><a id="iddle1278"></a><a id="iddle1366"></a><a
        id="iddle1423"></a><a id="iddle1674"></a>Notice that we’ll be using the token header this
            time. Next, verify the signature based on our shared secret, and that will be our first
            check of the token’s contents. Remember, our library needs the secret to be converted to
            hex before it can validate things.</p>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/191fig01_alt.png"
                width="1634" height="214"></p>

        <p>Take special note that we have passed in the token string exactly as it was handed to us
            on the wire. We didn’t use the decoded or parsed JSON objects, nor did we re-encode them
            on our own. Had we done any of that, it’s entirely possible (and completely legal) that
            the serialization of the JSON would have been slightly different, such as by adding or
            removing spaces and indentation or by re-ordering the members of a data object. As we
            discussed, the JOSE specifications effectively armor the token against transformation in
            transit specifically so that this validation step can be performed without any
            renormalization.</p>

        <p>Only if the signature is valid do we parse the JWT and check its contents for
            consistency. If all checks pass, we can hand it off to the application, as we did
            previously. Now the resource server will only accept tokens that have been signed by the
            secret that it shares with the authorization server. To test this, edit the secret in
            either the authorization server’s or protected resource’s code so that they differ. The
            resource server should reject the resulting token.</p>

        <h4 id="ch11lev2sec5">11.3.2. <a id="ch11lev2sec5__title"></a>Asymmetric signatures using
            RS256</h4>

        <p>In this section’s exercise, we’re once again going to sign the token with a secret key,
            as we did in the last section. However, this time, we’re going to use public key
            cryptography to do it. With a shared secret, both systems need the same key either to
            create or to validate the signature. This effectively means that either the
            authorization server or the resource server could create the tokens in the last
            exercise, because they both had access to the keying material needed to do so. With
            public key cryptography, the authorization server has both a private key and a public
            key that it can use to generate tokens, whereas the protected resource needs to be able
            to access only the authorization server’s public key to verify the token. Unlike with a
            shared secret, the protected resource has no way of generating its own valid tokens even
            though it can easily verify them. We’re going to be using the <kbd>RS256</kbd> signature
            method from JOSE, which uses the RSA algorithm under the hood.</p>

        <p>Open up <kbd>ch-11-ex-3</kbd> and start with the <kbd>authorizationServer.js</kbd> file.
            First, we need to add a public and private key pair to our authorization server. Our key
            pair is a 2048-bit RSA key, which is the minimum recommended size. We’re using keys
            stored in the JSON-based JWK format for this exercise, and they can be read natively by
            our library. To keep you from having to type in this convoluted set of characters <i>exactly</i>
            as <a id="iddle1438"></a>it’s written in the book, we’ve gone ahead and included it in
            the code for you, so go check it out.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14697">var rsaKey = {<span></span>
  "alg": "RS256",<span></span>
  "d": "ZXFizvaQ0RzWRbMExStaS_-yVnjtSQ9YslYQF1kkuIoTwFuiEQ2OywBfuyXhTvVQxIiJq<span></span>
     PNnUyZR6kXAhyj__wS_Px1EH8zv7BHVt1N5TjJGlubt1dhAFCZQmgz0D-PfmATdf6KLL4HIijG<span></span>
     rE8iYOPYIPF_FL8ddaxx5rsziRRnkRMX_fIHxuSQVCe401hSS3QBZOgwVdWEb1JuODT7KUk7xPp<span></span>
     MTw5RYCeUoCYTRQ_KO8_NQMURi3GLvbgQGQgk7fmDcug3MwutmWbpe58GoSCkmExUS0U-KEkH<span></span>
     tFiC8L6fN2jXh1whPeRCa9eoIK8nsIY05gnLKxXTn5-aPQzSy6Q",<span></span>
  "e": "AQAB",<span></span>
  "n": "p8eP5gL1H_H9UNzCuQS-vNRVz3NWxZTHYk1tG9VpkfFjWNKG3MFTNZJ1l5g_COMm2_2i_<span></span>
     YhQNH8MJ_nQ4exKMXrWJB4tyVZohovUxfw-eLgu1XQ8oYcVYW8ym6Um-BkqwwWL6CXZ70X81<span></span>
     YyIMrnsGTyTV6M8gBPun8g2L8KbDbXR1lDfOOWiZ2ss1CRLrmNM-GRp3Gj-ECG7_3Nx9n_s5<span></span>
     to2ZtwJ1GS1maGjrSZ9GRAYLrHhndrL_8ie_9DS2T-ML7QNQtNkg2RvLv4f0dpjRYI23djxV<span></span>
     tAylYK4oiT_uEMgSkc4dxwKwGuBxSO0g9JOobgfy0--FUHHYtRi0dOFZw",<span></span>
  "kty": "RSA",<span></span>
  "kid": "authserver"<span></span>
};</pre>
        </div>

        <p>This key pair was randomly generated, and in a production environment you’ll want to have
            a unique key for each service. As an added exercise, generate your own JWK using a JOSE
            library and replace the one in the code here.</p>

        <p>Next we need to sign the token using our private key. The process is similar to how we
            handled the shared secret, and we’ll be working in the token generation function again.
            First we need to indicate that our token is signed with the RS256 algorithm. We’re also
            going to indicate that we’re using the key with the key ID (<kbd>kid</kbd>) of -<kbd>authserver</kbd>
            from our authorization server. The authorization server may have only one key right now,
            but if you were to add other keys to this set, you’d want the resource server to be able
            to know which one you used.</p>
        <div data-testid="custom pre block">
            <pre id="PLd0e14715">var header = { 'typ': 'JWT', <b>'alg': rsaKey.alg, 'kid': rsaKey.kid</b> };</pre>
        </div>

        <p>Next, we need to convert our JWK-formatted key pair into a form that our library can use
            for cryptographic operations. Thankfully, our library gives us a simple utility for
            doing that.<sup>[<a href="#ch11fn07" aria-label="각주 7">7</a>]</sup> We can then use this
            key to sign the token.</p>

        <blockquote>
            <p><sup><a id="ch11fn07" aria-label="각주 7">7</a></sup></p>

            <p>
                Other libraries and other platforms may need to have key objects created from the
                different parts of the JWK.
            </p>


        </blockquote>
        <div data-testid="custom pre block">
            <pre id="PLd0e14731">var privateKey = jose.KEYUTIL.getKey(rsaKey);</pre>
        </div>

        <p>Then we’ll create our access token string much like we did before, except this time we
            use our private key and the RS256 asymmetric signing algorithm.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14740">var access_token = jose.jws.JWS.sign(header.alg,<span></span>
  JSON.stringify(header),<span></span>
  JSON.stringify(payload),<span></span>
  privateKey);</pre>
        </div>

        <p><a id="iddle1643"></a>The result is the token similar to the previous one, but it’s now
            been signed asymmetrically.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14755">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6ImF1dGhzZXJ2ZXIifQ.eyJpc3MiOiJodH<span></span>
   RwOi8vbG9jYWxob3N0OjkwMDEvIiwic3ViIjoiOVhFMy1KSTM0LTAwMTMyQSIsImF1ZCI6Imh<span></span>
   0dHA6Ly9sb2NhbGhvc3Q6OTAwMi8iLCJpYXQiOjE0NjcyNTE5NjksImV4cCI6MTQ2NzI1MjI2<span></span>
   OSwianRpIjoidURYMWNwVnYifQ.nK-tYidfd6IHW8iwJ1ZHcPPnbDdbjnveunKrpOihEb0JD5w<span></span>
   fjXoYjpToXKfaSFPdpgbhy4ocnRAfKfX6tQfJuFQpZpKmtFG8OVtWpiOYlH4Ecoh3soSkaQyIy<span></span>
   4L6p8o3gmgl9iyjLQj4B7Anfe6rwQlIQi79WTQwE9bd3tgqic5cPBFtPLqRJQluvjZerkSdUo<span></span>
   7Kt8XdyGyfTAiyrsWoD1H0WGJm6IodTmSUOH7L08k-mGhUHmSkOgwGddrxLwLcMWWQ6ohmXa<span></span>
   Vv_Vf-9yTC2STHOKuuUm2w_cRE1sF7JryiO7aFRa8JGEoUff2moaEuLG88weOT_S2EQBhYB<span></span>
   0vQ8A</pre>
        </div>

        <p>The header and payload are still Base64URL-encoded JSON, and the signature is a
            Base64URL-encoded array of bytes. The signature is much longer now as a result of using
            the RSA algorithm.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14764">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6ImF1dGhzZXJ2ZXIifQ<span></span>
.<span></span>
eyJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjkwMDEvIiwic3ViIjoiOVhFMy1KSTM0L<span></span>
   TAwMTMyQSIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6OTAwMi8iLCJpYXQiOjE0<span></span>
   NjcyNTE5NjksImV4cCI6MTQ2NzI1MjI2OSwianRpIjoidURYMWNwVnYifQ<span></span>
.<span></span>
<b>nK-tYidfd6IHW8iwJ1ZHcPPnbDdbjnveunKrpOihEb0JD5wfjXoYjpToXKfaSFPdpgbhy4ocnRAfKfX6tQfJuFQpZpKmtFG8OVtWpiOYlH4Ecoh3soSkaQyIy4L6p8o3gmgl9iyjLQj4B7Anfe6rwQlI</b>
   <b>Qi79WTQwE9bd3tgqic5cPBFtPLqRJQluvjZerkSdUo7Kt8XdyGyfTAiyrsWoD1H0WGJm6IodTmS</b>
   <b>UOH7L08k-mGhUHmSkOgwGddrxLwLcMWWQ6ohmXaVv_Vf-9yTC2STHOKuuUm2w_cRE1sF7JryiO7</b>
   <b>aFRa8JGEoUff2moaEuLG88weOT_S2EQBhYB0vQ8A</b></pre>
        </div>

        <p>The client once again remains unchanged, but we do have to tell the protected resource
            how to validate the signature of this new JWT. Open up <kbd>protectedResource.js</kbd>
            so that we can tell it the server’s public key. Once again, instead of making you
            painstakingly transcribe the key information, we’ve gone ahead and included it in the
            file for you.</p>
        <div data-testid="custom pre block"><pre id="PLd0e14787">var rsaKey = {<span></span>
  "alg": "RS256",<span></span>
  "e": "AQAB",<span></span>
  "n": "p8eP5gL1H_H9UNzCuQS-vNRVz3NWxZTHYk1tG9VpkfFjWNKG3MFTNZJ1l5g_COMm2_2i_<span></span>
     YhQNH8MJ_nQ4exKMXrWJB4tyVZohovUxfw-eLgu1XQ8oYcVYW8ym6Um-BkqwwWL6CXZ70X81<span></span>
     YyIMrnsGTyTV6M8gBPun8g2L8KbDbXR1lDfOOWiZ2ss1CRLrmNM-GRp3Gj-ECG7_3Nx9n_s5<span></span>
     to2ZtwJ1GS1maGjrSZ9GRAYLrHhndrL_8ie_9DS2T-ML7QNQtNkg2RvLv4f0dpjRYI23djxV<span></span>
     tAylYK4oiT_uEMgSkc4dxwKwGuBxSO0g9JOobgfy0--FUHHYtRi0dOFZw",<span></span>
  "kty": "RSA",<span></span>
  "kid": "authserver"<span></span>
};</pre>
        </div>

        <p>This data is from the same key pair as the one in the authorization server, but it
            doesn’t contain the private key information (represented by the <kbd>d</kbd> element in
            an RSA key). The effect is that the protected resource can only verify incoming signed
            JWTs, but it cannot create them.</p>


        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <div>
            <p><b id="ch11sb02">Do I have to copy my keys all over the place?</b></p>
            <p><a id="iddle1524"></a><a id="iddle1570"></a>You might think it’s onerous to copy
                signing and verification keys between pieces of software like this, and you’d be
                right. If the authorization server ever decides to update its keys, all copies of
                the corresponding public key need to be updated in all protected resources
                downstream. For a large OAuth ecosystem, that can be problematic.</p>

            <p>One common approach, used by the OpenID Connect protocol that we’ll cover in <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_026.html#ch13">chapter
                13</a>, is to have the authorization server publish its <i>public</i> key at a known
                URL. This will generally take the form of a JWK Set, which can contain multiple keys
                and looks something like this.</p>
            <div data-testid="custom pre block"><pre id="PLd0e14828">{<span></span>
  "keys": [<span></span>
    {<span></span>
      "alg": "RS256",<span></span>
      "e": "AQAB",<span></span>
     "n": "p8eP5gL1H_H9UNzCuQS-vNRVz3NWxZTHYk1tG9VpkfFjWNKG3MFTNZJ1l5g_<span></span>
COMm2_2i_YhQNH8MJ_nQ4exKMXrWJB4tyVZohovUxfw-eLgu1XQ8oYcVYW8ym6Um-Bkqww<span></span>
WL6CXZ70X81YyIMrnsGTyTV6M8gBPun8g2L8KbDbXR1lDfOOWiZ2ss1CRLrmNM-GRp3Gj-<span></span>
ECG7_3Nx9n_s5to2ZtwJ1GS1maGjrSZ9GRAYLrHhndrL_8ie_9DS2T-ML7QNQtNkg2RvLv4f<span></span>
0dpjRYI23djxVtAylYK4oiT_uEMgSkc4dxwKwGuBxSO0g9JOobgfy0--FUHHYtRi0dOFZw",<span></span>
      "kty": "RSA",<span></span>
      "kid": "authserver"<span></span>
    }<span></span>
  ]<span></span>
}</pre>
            </div>

            <p>The protected resources can then fetch and cache this key as needed. This approach
                allows the authorization server to rotate its keys whenever it sees fit, or add new
                keys over time, and the changes will automatically propagate throughout the
                network.</p>

            <p>For an added exercise, modify the server to publish its public key as a JWK set, and
                modify the protected resource to fetch this key over the network as needed. Be very
                careful that the authorization server publishes only its <i>public</i> key and not
                the <i>private</i> key as well!</p>
        </div>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <p>Now we’ll use our library to validate the signatures of incoming tokens based on the
            server’s public key. Load up the public key into an object that our library can use, and
            then use that key to validate the token’s signature.</p>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/194fig01_alt.jpg"
                width="590" height="95"></p>

        <p>We’ll still need to perform all the same checks against the token that we performed when
            we had an unsigned token. The payload object is once again handed off to <a
            id="iddle1280"></a><a id="iddle1312"></a><a id="iddle1325"></a><a id="iddle1326"></a><a
            id="iddle1327"></a><a id="iddle1368"></a><a id="iddle1369"></a><a id="iddle1422"></a><a
            id="iddle1566"></a><a id="iddle1567"></a><a id="iddle1568"></a><a id="iddle1640"></a><a
            id="iddle1641"></a><a id="iddle1642"></a><a id="iddle1673"></a><a id="iddle1698"></a>the
            rest of the application to allow it to decide whether the presented token is sufficient
            for the given request. Now that this has been set up, the authorization server can
            choose to include additional information for the protected resource’s consumption, such
            as scopes or client identifiers. For an additional exercise, add some of this
            information in using your own JWT claims and have the protected resource reach to their
            values.</p>

        <h4 id="ch11lev2sec6">11.3.3. <a id="ch11lev2sec6__title"></a>Other token protection options
        </h4>

        <p>The methods that we’ve gone over in these exercises aren’t the only JOSE-based means of
            protecting a token’s contents. For instance, we used the HS256 symmetric signature
            method previously, which provides a 256-byte hash of the token’s contents. JOSE also
            defines HS384 and HS512, both of which use larger hashes to provide increased security
            at the cost of larger token signatures. Similarly, we used the RS256 asymmetric
            signature method, which provides a 256-byte hash of the RSA signature output. JOSE also
            defines the RS384 and RS512 methods, with the same kinds of trade-offs as their
            symmetric counterparts. JOSE also defines the PS256, PS384, and PS512 signature methods,
            all based on a different RSA signature and hashing mechanism.</p>

        <p>JOSE also provides elliptical curve support, with the core standard referencing three
            curves and associated hashes in ES256, ES384, and ES512. Elliptical curve cryptography
            has several benefits over RSA cryptography, including smaller signature sizes and lower
            processing requirements for validation, but support for the underlying cryptographic
            functions isn’t nearly as widespread as RSA at the time of this writing. On top of this,
            JOSE’s list of algorithms is extensible by new specifications, allowing new algorithms
            to be defined as they’re invented and needed.</p>

        <p>Sometimes signatures aren’t enough, though. With a token that’s only signed, the client
            could potentially peek at the token itself and find out things that it might not be
            privileged to know, such as a user identifier in the <kbd>sub</kbd> field. The good news
            is that in addition to signatures, JOSE provides an encryption mechanism called JWE with
            several different options and algorithms. Instead of a three-part structure, a JWT
            encrypted with JWE is a five-part structure. Each portion still uses Base64 URL
            encoding, and the payload is now an encrypted object that can’t be read without access
            to the appropriate key. Covering the JWE process is a bit much for this chapter, but for
            an advanced exercise try adding JWE to the tokens. First, give the resource server a key
            pair and give the authorization server access to the public key portion of this key
            pair. Then use the public key to encrypt the contents of the token using JWE. Finally,
            have the resource server decrypt the contents of the token using its own private key and
            pass the payload of the token along to the application.</p>


        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <div>
            <p><b id="ch11sb03">Let’s get COSE<sup>[<a href="#ch11fn08"
                                                       aria-label="각주 8">8</a>]</sup></b></p>
            <p>An emerging standard called CBOR Object Signing and Encryption (COSE) provides much
                of the same functionality of JOSE but based on the Concise Binary Object
                Representation (CBOR) data serialization. As its name suggests, CBOR is a
                non-human-readable binary format that’s designed for environments in which space is
                at a premium. Its underlying data model is based on JSON, and anything represented
                in JSON can easily be translated into CBOR. The COSE specification is attempting to
                do for CBOR what JOSE did for JSON before it, which means that it will likely become
                a viable option for compact JWT-like tokens in the near future.</p>
        </div>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <blockquote>
            <p><sup><a id="ch11fn08" aria-label="각주 8">8</a></sup></p>

            <p><a id="iddle1165"></a><a id="iddle1254"></a><a id="iddle1267"></a><a
            id="iddle1404"></a><a id="iddle1409"></a><a id="iddle1410"></a><a id="iddle1755"></a><a
            id="iddle1759"></a>Pronounced “cozy”, as in “a cozy couch.”
            </p>


        </blockquote>

        <h3 id="ch11lev1sec4"><a id="ch11lev1sec4__title"></a>11.4. Looking up a token’s information
            online: token introspection</h3>

        <p>Packing the information about the token into the token itself does have its drawbacks.
            The tokens themselves can grow to be quite large as they incorporate all the required
            claims and cryptographic structures required to protect those claims. Furthermore, if
            the protected resource is relying solely on information carried in the token itself, it
            becomes prohibitively difficult to revoke active tokens once they’ve been created and
            sent into the wild.</p>

        <h4 id="ch11lev2sec7">11.4.1. <a id="ch11lev2sec7__title"></a>The introspection protocol
        </h4>

        <p>The OAuth Token Introspection protocol<sup>[<a href="#ch11fn09" aria-label="각주 9">9</a>]</sup>
            defines a mechanism for a protected resource to actively query an authorization server
            about the state of the token. Since the authorization server minted the token, it’s in
            the perfect position to know the surrounding details of the authorization delegation
            that the token represents.</p>

        <blockquote>
            <p><sup><a id="ch11fn09" aria-label="각주 9">9</a></sup></p>


        </blockquote>

        <p>The protocol is a simple augmentation of OAuth. The authorization server issues the token
            to the client, the client presents the token to the protected resource, and the
            protected resource introspects the token at the authorization server (<a
            href="#ch11fig02">figure 11.2</a>).</p>

        <h5 id="ch11fig02">Figure 11.2. <a id="ch11fig02__title"></a>Connecting the protected
            resource to the authorization server</h5>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/11fig02_alt.jpg"
                width="590" height="401"></p>

        <p>The introspection request is a form-encoded HTTP request to the authorization server’s
            introspection endpoint, which allows the protected resource to ask, “Someone gave me
            this token; what is it good for?” of the authorization server. The protected resource
            authenticates itself during this request so that the authorization server can tell who
            is asking the question and potentially give a different response depending on who’s
            asking. The introspection specification doesn’t dictate <i>how</i> the protected
            resource needs to authenticate itself, only that it does so. In our example, the
            protected resource authenticates using an ID and secret over HTTP Basic, much in the
            same way that an OAuth client would authenticate itself to the token endpoint. This
            could also be accomplished using a separate access token, which is how the UMA protocol
            discussed in <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_027.html#ch14">chapter
                14</a> does it.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15091">POST /introspect HTTP/1.1<span></span>
Host: localhost:9001<span></span>
Accept: application/json<span></span>
Content-type: application/x-www-form-encoded<span></span>
Authorization: Basic cHJvdGVjdGVkLXJlc291cmNlLTE6cHJvdGVjdGVkLXJlc291cmNlLXNlY3JldC0x<span></span>
<span></span>
token=987tghjkiu6trfghjuytrghj</pre>
        </div>

        <p>The introspection response is a JSON document that describes the token. Its contents are
            similar to the payload of a JWT, and any valid JWT claim can be used as part of the
            response.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15100">HTTP 200 OK<span></span>
Content-type: application/json<span></span>
<span></span>
{<span></span>
  "active": true,<span></span>
  "scope": "foo bar baz",<span></span>
  "client_id": "oauth-client-1",<span></span>
  "username": "alice",<span></span>
  "iss": "http://localhost:9001/",<span></span>
  "sub": "alice",<span></span>
  "aud": "http://localhost:/9002/",<span></span>
  "iat": 1440538696,<span></span>
  "exp": 1440538996,<span></span>
}</pre>
        </div>

        <p><a id="iddle1019"></a><a id="iddle1320"></a><a id="iddle1345"></a><a
        id="iddle1405"></a><a id="iddle1756"></a>The introspection specification also defines
            several claims in addition to those defined by JWT, the most important of which is the
            <kbd>active</kbd> claim. This claim tells the protected resource whether the current
            token is active at the authorization server, and it’s the only claim required to be
            returned. Because there are many different kinds of OAuth token deployments, there is no
            single definition of what an active token is. In general, though, this means that the
            token was issued by this authorization server, it hasn’t expired yet, it hasn’t been
            revoked, and the requesting protected resource is allowed to fetch information about it.
            Interestingly, this piece of information is something that can’t be included in the
            token itself, since no token would ever claim to be non-active.</p>

        <p>The introspection response may also include the scope of the token, represented as a
            space-separated list of scope strings as in the original OAuth request. As we’ve seen in
            <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_015.html#ch04">chapter
                4</a>, the scope of a token allows a protected resource to determine the rights
            delegated to the client by the resource owner in a more fine-grained manner. Finally,
            information about the client and user can also be included. All of this together can
            give the protected resource a rich set of data from which to make the final
            authorization decision.</p>

        <p>The use of token introspection incurs the overhead of increased network traffic on the
            OAuth systems. To combat this, the protected resource is allowed to cache the results of
            the introspection call for a given token. It’s recommended that the cache be short lived
            relative to the expected lifetime of the token in order to limit the chance of a token
            being revoked while the cache is in effect.</p>

        <h4 id="ch11lev2sec8">11.4.2. <a id="ch11lev2sec8__title"></a>Building the introspection
            endpoint</h4>

        <p>Now we’re going to build introspection support into our applications. Open up <kbd>ch-11-ex-4</kbd>
            and start with the <kbd>authorizationServer.js</kbd> where we’re going to build the
            introspection endpoint. First, we’ll add some credentials for our protected resource
            that will allow it to authenticate to our introspection endpoint.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15174">var protectedResources = [<span></span>
  {<span></span>
      "resource_id": "protected-resource-1",<span></span>
      "resource_secret": "protected-resource-secret-1"<span></span>
  }<span></span>
];</pre>
        </div>

        <p>We’re deliberately modeling this off client authentication, which is one of the default
            options given by the introspection specification for protected resource authentication.
            We’ve included a <kbd>getProtectedResource</kbd> function to mirror the
            <kbd>getClient</kbd> function we created in <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_016.html#ch05">chapter
                5</a>.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15192">var getProtectedResource = function(resourceId) {<span></span>
  return __.find(protectedResources, function(protectedResource) { return protectedResource.resource_id == resourceId; });<span></span>
};</pre>
        </div>

        <p>We’re going to host our introspection endpoint at <kbd>/introspect</kbd> on our
            authorization server, and it’s going to listen for POST requests.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15206">app.post('/introspect', function(req, res) {<span></span>
<span></span>
});</pre>
        </div>

        <p><a id="iddle1120"></a>Our protected resource is going to authenticate using HTTP Basic
            authentication and a shared secret, so we’ll look for that in the
            <kbd>Authorization</kbd> header as we do for client credentials at the token endpoint.
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e15223">var auth = req.headers['authorization'];<span></span>
var resourceCredentials = decodeClientCredentials(auth);<span></span>
var resourceId = resourceCredentials.id;<span></span>
var resourceSecret = resourceCredentials.secret;</pre>
        </div>

        <p>Once we have the presented credentials, look up the resource using our helper function
            and figure out whether or not the secret matches.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15232">var resource = getProtectedResource(resourceId);<span></span>
if (!resource) {<span></span>
  res.status(401).end();<span></span>
  return;<span></span>
}<span></span>
<span></span>
if (resource.resource_secret != resourceSecret) {<span></span>
  res.status(401).end();<span></span>
  return;<span></span>
}</pre>
        </div>

        <p>Now we have to look up the token in our database. If we find the token, we’re going to
            add all the information that we have about the token to our response and send it back as
            a JSON object. If we don’t find the token, we send back only a notification that the
            token was not active.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15241">var inToken = req.body.token;<span></span>
console.log('Introspecting token %s', inToken);<span></span>
nosql.one().make(function(builder) {<span></span>
  builder.where('access_token', inToken);<span></span>
  builder.callback(function(err, token) {<span></span>
    if (token) {<span></span>
      var introspectionResponse = {<span></span>
        active: true,<span></span>
        iss: 'http://localhost:9001/',<span></span>
        aud: 'http://localhost:9002/',<span></span>
        sub: token.user ? token.user.sub : undefined,<span></span>
        username: token.user ? token.user.preferred_username : undefined,<span></span>
        scope: token.scope ? token.scope.join(' ') : undefined,<span></span>
        client_id: token.client_id <span></span>
      };<span></span>
       res.status(200).json(introspectionResponse);<span></span>
      return;<span></span>
    } else {<span></span>
      var introspectionResponse = {<span></span>
        active: false<span></span>
      };       res.status(200).json(introspectionResponse);<span></span>
      return;<span></span>
    }<span></span>
  });<span></span>
});</pre>
        </div>

        <p><a id="iddle1407"></a><a id="iddle1758"></a>For security reasons, it’s important that we
            don’t tell the protected resource exactly why the token wasn’t active—whether it
            expired, was revoked, or was never issued in the first place—but instead say that it
            wasn’t any good. Otherwise, a compromised protected resource could be used by an
            attacker to fish about at the authorization server for information about tokens. For
            legitimate transactions, it ultimately doesn’t matter <i>why</i> the token isn’t good,
            only that it’s not.</p>

        <p>Bringing it all together, our introspection endpoint looks like <a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_031.html#app02ex11">listing
            11</a> in <a
        href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_031.html#app02">appendix
            B</a>. The introspection endpoint is supposed to look up refresh tokens as well, but
            we’re leaving that additional functionality as an exercise to the reader.</p>

        <h4 id="ch11lev2sec9">11.4.3. <a id="ch11lev2sec9__title"></a>Introspecting a token</h4>

        <p>Now that we have an introspection endpoint to call, we need to set up our protected
            resource to call it. We’re going to continue in the same exercise from the last section,
            <kbd>ch-11-ex-4</kbd>, but now open up <kbd>protectedResource.js</kbd> and edit it.
            Start off by giving the protected resource its ID and secret, as we did with our client
            in <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_016.html#ch05">chapter
                5</a>.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15301">var protectedResource = {<span></span>
  "resource_id": "protected-resource-1",<span></span>
  "resource_secret": "protected-resource-secret-1"<span></span>
};</pre>
        </div>

        <p>Next, inside the <kbd>getAccessToken</kbd> function, we’re going to call the
            introspection endpoint. This is a simple HTTP POST with the previous ID and secret sent
            as HTTP Basic parameters and the token value that was received from the client sent as a
            form parameter.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15313">var form_data = qs.stringify({<span></span>
  token: inToken<span></span>
});<span></span>
var headers = {<span></span>
  'Content-Type': 'application/x-www-form-urlencoded',<span></span>
'Authorization': 'Basic ' + encodeClientCredentials(protectedResource.resource_id, protectedResource.resource_secret)<span></span>
};<span></span>
<span></span>
var tokRes = request('POST', authServer.introspectionEndpoint, {<span></span>
  body: form_data,<span></span>
  headers: headers<span></span>
});</pre>
        </div>

        <p>Finally, take the response from the introspection endpoint and parse it as a JSON object.
            If the active claim comes back as true, then pass the result of the introspection call
            in to the rest of the application for further processing.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15324">if (tokRes.statusCode &gt;= 200 &amp;&amp; tokRes.statusCode &lt; 300) {<span></span>
  var body = JSON.parse(tokRes.getBody());<span></span>
<span></span>
  console.log('Got introspection response', body);<span></span>
  var active = body.active;<span></span>
  if (active) {<span></span>
      req.access_token = body;<span></span>
  }<span></span>
}</pre>
        </div>

        <p><a id="iddle1406"></a><a id="iddle1435"></a><a id="iddle1482"></a><a
        id="iddle1512"></a><a id="iddle1707"></a><a id="iddle1757"></a>From here, the protected
            resource serving functions will decide whether the token is sufficient or appropriate
            for the request at hand.</p>

        <h4 id="ch11lev2sec10">11.4.4. <a id="ch11lev2sec10__title"></a>Combining introspection and
            JWT</h4>

        <p>In this chapter, we’ve presented structured tokens (specifically JWT) and token
            introspection as two alternative ways to carry information between the authorization
            server and the protected resource. It might seem as though you need to pick either one
            method or the other, but in truth, they can be used together to great effect.</p>

        <p>The JWT can be used to carry core information, for example, the expiration, unique
            identifier, and issuer. These pieces of information are going to be needed by every
            protected resource to provide a first-order check of whether the token is trusted. From
            there, the protected resource can perform token introspection to determine more detailed
            (and potentially sensitive) information about the token, such as the user who authorized
            it, the client it was issued to, and the scopes it was issued with.</p>

        <p>This approach is particularly useful in cases in which a protected resource is set up to
            accept access tokens from a variety of authorization servers. The protected resource can
            parse the JWT to find out which authorizations server issued the token and then
            introspect the token at the correct authorization server to find out more.</p>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <div>
            <p><b id="ch11sb04">The state of the token</b></p>
            <p>For a client, it doesn’t matter if its token was revoked by another party, since
                OAuth clients always need to be ready to go get a new token. The OAuth protocol
                doesn’t differentiate error responses based on whether the token was revoked,
                expired, or otherwise invalid, because the client’s response is always the same.</p>

            <p>However, as a protected resource, it’s definitely important to know whether a token
                was revoked or not, because accepting a revoked token would be a huge security hole.
                Huge security holes are generally considered bad things to have. If the protected
                resource uses a local database lookup or a live query such as introspection, it can
                find out easily and quickly that a token was revoked. But what if it’s using a
                JWT?</p>

            <p>Since a JWT is ostensibly self-contained, it’s considered <i>stateless</i>. There’s
                no way to indicate to a protected resource that it has been revoked without
                resorting to external signals. The same problem occurs in a certificate-based public
                key infrastructure (PKI), in which a certificate is valid if all of the signatures
                match. The revocation problem was addressed here using <i>certificate revocation
                    lists</i> and the <i>online certificate status protocol (OCSP),</i> equivalent
                to token introspection in the OAuth world.</p>
        </div>

        <table>
            <colgroup>
                <col width="550">
            </colgroup>
            <tbody>
            <tr>
                <td></td>
            </tr>
            </tbody>
        </table>

        <h3 id="ch11lev1sec5"><a id="ch11lev1sec5__title"></a>11.5. Managing the token lifecycle
            with token revocation</h3>

        <p><a id="iddle1481"></a><a id="iddle1635"></a><a id="iddle1637"></a><a
        id="iddle1738"></a><a id="iddle1777"></a><a id="iddle1780"></a>OAuth tokens usually follow a
            predictable lifecycle. They’re created by the authorization server, used by the client,
            and validated by the protected resource. They might expire on their own or be revoked by
            the resource owner (or an administrator) at the authorization server. OAuth’s core
            specifications provide mechanisms for getting and using tokens in a variety of ways, as
            we’ve seen. A refresh token even allows a client to request a new access token to
            replace an invalidated one. In <a href="#ch11lev1sec2">sections 11.2</a> and <a
            href="#ch11lev1sec3">11.3</a>, we’ve seen how JWT and token introspection can be used to
            help a protected resource validate a token. Sometimes, though, the client knows that it
            will no longer need a token. Does it need to wait for the token to expire, or for
            someone else to revoke it?</p>

        <p>So far, we haven’t seen any mechanism that would let the client tell the authorization
            server to revoke otherwise valid tokens, but this is where the OAuth Token Revocation
            specification<sup>[<a href="#ch11fn10" aria-label="각주 10">10</a>]</sup> comes in. This
            specification allows clients to be proactive in managing token lifecycles in response to
            triggering events on the client side. For instance, the client may be a native
            application being uninstalled from the user’s device, or it may provide a user interface
            that allows the user to deprovision the client. Perhaps, even, the client software has
            detected suspicious behavior and wants to limit the damage to the protected resources it
            has been authorized for. Whatever the triggering event, the token revocation
            specification lets the client signal the authorization server that the tokens it has
            issued should no longer be used.</p>

        <blockquote>
            <p><sup><a id="ch11fn10" aria-label="각주 10">10</a></sup></p>


        </blockquote>

        <h4 id="ch11lev2sec11">11.5.1. <a id="ch11lev2sec11__title"></a>The token revocation
            protocol</h4>

        <p>OAuth token revocation is a simple protocol that allows a client to say, succinctly, “I
            have this token and I want you to get rid of it” to an authorization server. Much like
            token introspection that we covered in <a href="#ch11lev1sec4">section 11.4</a>, the
            client makes an authenticated HTTP POST request to a special endpoint, the revocation
            endpoint, with the token to be revoked as a form-encoded parameter in the request body.
        </p>
        <div data-testid="custom pre block"><pre id="PLd0e15497">POST /revoke HTTP/1.1<span></span>
Host: localhost:9001<span></span>
Accept: application/json<span></span>
Content-type: application/x-www-form-encoded<span></span>
Authorization: Basic b2F1dGgtY2xpZW50LTE6b2F1dGgtY2xpZW50LXNlY3JldC0x<span></span>
<span></span>
token=987tghjkiu6trfghjuytrghj</pre>
        </div>

        <p>The client authenticates as it would with a request to the token endpoint, using the same
            credentials. The authorization server looks up the token value. If it can find it, it
            deletes it from whatever data store it’s using to keep tokens and responds to the client
            that everything went OK.</p>


        <p>Really, that’s it. The client discards its own copy of the token and goes on its way.</p>

        <p><a id="iddle1137"></a><a id="iddle1321"></a><a id="iddle1379"></a><a
        id="iddle1636"></a><a id="iddle1778"></a>If the authorization server can’t find the token,
            or the client presenting the token isn’t allowed to revoke that token, the authorization
            server responds that everything went OK. Why don’t we return an error in these cases? If
            we did, we’d be inadvertently giving clients information about tokens other than their
            own. For instance, let’s say that we returned an HTTP 403 Forbidden to a client that was
            trying to revoke a token from another client. In this case, we probably don’t want to
            revoke that token, since that would open up a denial of service attack against other
            clients.<sup>[<a href="#ch11fn11" aria-label="각주 11">11</a>]</sup> However, we also
            don’t want to tell the client that the token that it has acquired, through whatever
            means, is valid and could be used elsewhere. To prevent that information from leaking,
            we pretend that we’ve revoked the token every time. To a well-behaving client, this
            makes no difference in function, and to a malicious client we haven’t disclosed anything
            that we don’t intend to. We do, of course, still respond appropriately for errors in
            client authentication, just as we would from the token endpoint.</p>

        <blockquote>
            <p><sup><a id="ch11fn11" aria-label="각주 11">11</a></sup></p>

            <p>
                At the risk of complicating matters even more, the details of this specific use case
                are a bit more subtle because we can now detect that one client has been compromised
                and had its tokens stolen, and we probably want to do something about that.
            </p>


        </blockquote>

        <h4 id="ch11lev2sec12">11.5.2. <a id="ch11lev2sec12__title"></a>Implementing the revocation
            endpoint</h4>

        <p>We’ll now be adding revocation support to our authorization server. Open up <kbd>ch-11-ex-5</kbd>
            and edit the <kbd>authorizationServer.js</kbd> file. We’re going to set up our
            revocation endpoint on <kbd>/revoke</kbd> on our authorization server, listening to HTTP
            POST messages. We’re going to be importing the client authentication code directly from
            our token endpoint as well.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15578">app.post('/revoke', function(req, res) {<span></span>
  var auth = req.headers['authorization'];<span></span>
  if (auth) {<span></span>
      var clientCredentials = decodeClientCredentials(auth);<span></span>
      var clientId = clientCredentials.id;<span></span>
      var clientSecret = clientCredentials.secret;<span></span>
  }<span></span>
<span></span>
  if (req.body.client_id) {<span></span>
      if (clientId) {<span></span>
            res.status(401).json({error: 'invalid_client'});<span></span>
            return;<span></span>
      }<span></span>
<span></span>
      var clientId = req.body.client_id;<span></span>
      var clientSecret = req.body.client_secret;<span></span>
  }<span></span>
<span></span>
  var client = getClient(clientId);<span></span>
  if (!client) {<span></span>
      res.status(401).json({error: 'invalid_client'});<span></span>
      return;<span></span>
  }<span></span>
  if (client.client_secret != clientSecret) {<span></span>
      res.status(401).json({error: 'invalid_client'});<span></span>
      return;<span></span>
  }<span></span>
<span></span>
});</pre>
        </div>

        <p><a id="iddle1638"></a><a id="iddle1779"></a><a id="iddle1794"></a>The revocation endpoint
            takes in one required argument, <kbd>token</kbd>, as a form-encoded parameter in the
            body of an HTTP POST, in the same manner as the introspection endpoint. We’ll parse out
            that token and look it up in our database. If we find it, and the client that’s making
            the request is the same as the one that the token was issued to, we’ll remove it from
            the database.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15616">var inToken = req.body.token;<span></span>
nosql.remove().make(function(builder) {<span></span>
  builder.and();<span></span>
  builder.where('access_token', inToken);<span></span>
  builder.where('client_id', clientId);<span></span>
  builder.callback(function(err, count) {<span></span>
    console.log("Removed %s tokens", count);<span></span>
    res.status(204).end();<span></span>
    return;<span></span>
  });<span></span>
});<span></span>
</pre>
        </div>

        <p>Whether we remove the token or not, we act as if we have done so and tell the client that
            everything is OK. Our final function looks like <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_031.html#app02ex12">listing
                12</a> in <a
            href="https://learning.oreilly.com/library/view/oauth-2-in/9781617293276/OEBPS/Text/kindle_split_031.html#app02">appendix
                B</a>.</p>

        <p>As with introspection, the authorization server also needs to be able to respond to
            requests to revoke refresh tokens, so a fully compliant implementation will need to
            check the data store for refresh tokens in addition to access tokens. The client can
            even send a <kbd>token_type_hint</kbd> parameter that tells the authorization server
            where to check first, though the authorization server is free to ignore this advice and
            check everywhere. Furthermore, if a refresh token is revoked, all access tokens
            associated with that refresh token should also be revoked at the same time.
            Implementation of this functionality is left as an exercise to the reader.</p>

        <h4 id="ch11lev2sec13">11.5.3. <a id="ch11lev2sec13__title"></a>Revoking a token</h4>

        <p>Now we’re going to let our client revoke a token. We’re going to be revoking tokens in
            reaction to an HTTP POST to a URL on the client. We’ve already wired up a new button on
            the client’s homepage to let you access the functionality from the UI. In a production
            system, you would want this functionality to be protected in order to prevent external
            applications and websites from revoking your application’s tokens without its knowledge
            (<a href="#ch11fig03">figure 11.3</a>).</p>

        <h5 id="ch11fig03">Figure 11.3. <a id="ch11fig03__title"></a>The client’s homepage with a
            control to trigger token revocation</h5>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/11fig03_alt.jpg"
                width="590" height="258"></p>

        <p>We’ll start by wiring up a handler for the <kbd>/revoke</kbd> URL, listening for HTTP
            POST requests.</p>
        <div data-testid="custom pre block"><pre id="PLd0e15668">app.post('/revoke', function(req, res) {<span></span>
<span></span>
});</pre>
        </div>

        <p>Inside this method, we’re going to create a request to the revocation endpoint. The
            client will authenticate using its regular credentials, passed over the HTTP Basic
            Authorization header, and it will pass its access token as a form parameter in the
            request body.</p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15678">var form_data = qs.stringify({<span></span>
  token: access_token<span></span>
});<span></span>
var headers = {<span></span>
  'Content-Type': 'application/x-www-form-urlencoded',<span></span>
  'Authorization': 'Basic ' + encodeClientCredentials(client.client_id, client.client_secret)<span></span>
};<span></span>
<span></span>
var tokRes = request('POST', authServer.revocationEndpoint, {<span></span>
  body: form_data,<span></span>
  headers: headers<span></span>
});</pre>
        </div>

        <p><span><span>응답이 성공 클래스 상태 코드와 함께 돌아오면, 우리는 애플리케이션의 메인 페이지를 다시 렌더링합니다. 오류 코드와 함께 돌아오면, 우리는 사용자에게 오류를 인쇄합니다. 어느 쪽이든, 우리는 우리 편에서 안전을 위해 액세스 토큰을 버립니다.</span></span>
        </p>
        <div data-testid="custom pre block"><pre
        id="PLd0e15687"><span><span>액세스 토큰 = null;</span></span><span></span><span><span>
새로 고침 토큰 = null;</span></span><span></span><span><span>
범위 = null;</span></span><span></span>
<span></span><span><span>
if (tokRes.statusCode &gt;= 200 &amp;&amp; tokRes.statusCode &lt; 300) {</span></span><span></span><span><span>
res.render('index', {액세스 토큰: 액세스 토큰, 새로 고침 토큰: 새로 고침 토큰, 범위: 범위});</span></span><span></span><span><span>
  반품;</span></span><span></span><span><span>
} 또 다른 {</span></span><span></span><span><span>
  res.render('error', {오류: tokRes.statusCode});</span></span><span></span><span><span>
  반품;</span></span><span></span><span><span>
}</span></span></pre>
        </div>

        <p><a id="iddle1441"></a><a id="iddle1763"></a><span><span>클라이언트는 거의 같은 방식으로 새로 고침 토큰을 취소하도록 요청할 수 있습니다. 권한 부여 서버가 이러한 요청을 받으면 새로 고침 토큰과 관련된 모든 액세스 토큰도 버려야 합니다. 이 기능의 구현은 독자의 연습으로 남겨둡니다.</span></span>
        </p>

        <h3 id="ch11lev1sec6"><a
        id="ch11lev1sec6__title"></a><span><span>11.6. OAuth 토큰 수명 주기</span></span></h3>

        <p><span><span>OAuth 액세스 토큰과 새로 고침 토큰은 명확한 수명 주기를 갖습니다. 이들은 권한 부여 서버에서 생성되고, 클라이언트에서 사용되며, 보호된 리소스에서 검증됩니다. 또한 만료 및 해지를 포함한 여러 요인에 의해 무효화될 수 있다는 것도 확인했습니다. 전반적으로 토큰 수명 주기는 </span></span><a
        href="#ch11fig04"><span><span>그림 11.4 에 표시된 것과 비슷할 수 있습니다.</span></span></a><span><span> 에 표시된 것과 비슷할 수 있습니다 .</span></span>
        </p>

        <h5 id="ch11fig04"><span><span>그림 11.4.</span></span><a
        id="ch11fig04__title"></a><span><span>OAuth 토큰 수명 주기</span></span></h5>

        <p><img alt=""
                src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781617293276/files/OEBPS/Images/11fig04_alt.jpg"
                width="590" height="936"></p>

        <p><span><span>이 특정 패턴이 점점 더 흔해지고 있지만, 만료되지만 취소할 수 없는 상태 없는 JWT를 사용하는 것과 같이 OAuth 시스템을 배포하는 다른 많은 방법이 있습니다. 그러나 전반적으로 토큰 사용, 재사용 및 새로 고침의 일반적인 패턴은 동일하게 유지됩니다.</span></span>
        </p>

        <h3 id="ch11lev1sec7"><a id="ch11lev1sec7__title"></a><span><span>11.7. 요약</span></span>
        </h3>

        <p><span><span>OAuth 토큰은 OAuth 시스템을 정의하는 핵심 구성 요소입니다.</span></span></p>


        <ul>
            <li><span><span>OAuth 토큰은 권한 부여 서버와 보호된 리소스에서 이해되는 한 어떤 형식이든 가능합니다.</span></span></li>

            <li><span><span>OAuth 클라이언트는 토큰 형식을 이해할 필요가 없습니다(어차피 그렇게 하려고 해서도 안 됩니다).</span></span>
            </li>

            <li><span><span>JWT는 토큰에 구조화된 정보를 저장하는 방법을 정의합니다.</span></span></li>

            <li><span><span>JOSE는 토큰의 내용을 암호화하여 보호하는 방법을 제공합니다.</span></span></li>

            <li><span><span>내성을 통해 보호된 리소스는 런타임에 토큰의 상태를 쿼리할 수 있습니다.</span></span></li>

            <li><span><span>해지를 통해 클라이언트는 발급된 토큰 중 원치 않는 토큰을 삭제하도록 권한 부여 서버에 신호를 보내 토큰 수명 주기를 완료할 수 있습니다.</span></span>
            </li>
        </ul>

        <p><span><span>이제 OAuth 토큰에 대한 전반적인 설명을 살펴보았으므로 동적 클라이언트 등록을 통해 클라이언트를 권한 부여 서버에 연결하는 방법을 살펴보겠습니다.</span></span>
        </p>


    </div>
</div>
<span></span> <!-- for IntersectionObserver -->


<style id="note-styling">
    .note {
      position: absolute;
      z-index: 10;
      border: none;
      outline: none;
      font-family: inherit;
      font-size: inherit;
      padding: 5px;
      min-width: 32px;
      min-height: 32px;
    }
    .note:focus {
      z-index: 11;
    }
    .note[type="0"] {
      background-color: #fff740;
      color: #2c2c2d;
    }
    .note[type="0"]::placeholder {
      color: #868226;
    }
    .note[type="1"] {
      background-color: #feff9c;
      color: #2c2c2d;
    }
    .note[type="1"]::placeholder {
      color: #6d6d3d;
    }
    .note[type="2"] {
      background-color: #ff65a3;
      color: #2c2c2d;
    }
    .note[type="2"]::placeholder {
      color: #65263f;
    }
    .note[type="3"] {
      background-color: #ff7eb9;
      color: #2c2c2d;
    }
    .note[type="3"]::placeholder {
      color: #562b3f;
    }
    .note[type="4"] {
      background-color: #7afcff;
      color: #295c5d;
    }
    .note[type="4"]::placeholder {
      color: #377677;
    }
</style>
</body>
<style>body {
      font-size:  19px;
      font-family: Helvetica, Arial, sans-serif;
      width: 950px;
    }
    p {
      text-align: justify
    }
    .page {
      line-height: 28.5px;
      column-count: unset;
    }
    h1, h2, h3 {
      line-height: initial;
    }
</style>
</html>